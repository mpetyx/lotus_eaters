__author__ = 'mpetyx (Michael Petychakis)'
__version__ = "1.0.0"
__maintainer__ = "Michael Petychakis"
__email__ = "hello@apilama.com"
__status__ = "Production"

"""External API for the throttle library.
Enables use of:
    pass
"""

import logging

from . import bucket


class Throttled(Exception):
    pass


class Throttler(object):
    def __init__(self, rate, capacity, storage, **kwargs):
        super(Throttler, self).__init__(**kwargs)
        self.rate = rate
        self.capacity = capacity
        self.storage = storage

    def get_bucket(self, key, rate=None, capacity=None, storage=None, **kwargs):
        """Fetch a Bucket for the given key.
        rate and capacity might be overridden from the Throttler defaults.
        Args:
            rate (float): Units regenerated by second, or None to keep
                Throttler defaults
            capacity (int): Maximum units available, or None to keep Throttler
                defaults
        """
        if storage:
            self.storage = storage

        return bucket.Bucket(
            key=key,
            rate=rate or self.rate,
            capacity=capacity or self.capacity,
            storage=self.storage,
            **kwargs)

    def consume(self, key, amount=1, rate=None, capacity=None, **kwargs):
        """Consume an amount for a given key.
        Non-default rate/capacity can be given to override Throttler defaults.
        Returns:
            bool: whether the units could be consumed
        """
        bucket = self.get_bucket(key, rate, capacity, self.storage,  **kwargs)
        return bucket.consume(amount)

    def throttle(self, key, amount=1, rate=None, capacity=None,
            exc_class=Throttled, **kwargs):
        """Consume an amount for a given key, or raise a Throttled exception."""

        if not self.consume(key, amount, rate, capacity, **kwargs):
            logging.warning("Request of %d unit for %s exceeds capacity.",
                    amount, key)
            return False
        return True


def consume(key, rate, capacity, storage, amount=1):
    thr = Throttler(rate, capacity, storage)
    return thr.consume(key, amount=amount)


def throttle(key, rate, capacity, storage, amount=1, exc_class=Throttled):
    """

    throttle uses the "token bucket" algorithm: for each key, a virtual bucket exists.

    Whenever a new request gets in, the algorithm performs the following actions:

    Test if adding the request's cost to the bucket would exceed its capacity; in that case, return False
    Otherwise, add the request's cost to the bucket, and return True
    Simultaneously, the bucket's current value is decremented at the chosen rate.

    This allows for temporary bursts and average computations.


    :param key:
    :param rate: this is the restore rate per second
    :param capacity: the overall capacity of the bucket at each moment
    :param storage: the storage engine, in our case Redis
    :param amount: the amount of values to enter at a given time
    :param exc_class:

    :return:
    """
    thr = Throttler(rate, capacity, storage)
    return thr.throttle(key, amount=amount, exc_class=exc_class)
